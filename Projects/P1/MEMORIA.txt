-----------------------------------
-MEMORIA P1: Llamadas al sistema--
-----------------------------------

Indice
    1. Objetivos
    2. Planteamiento y desarrollo
    3. Observaciones


1.

Para esta primera práctica, analizaremos en detalle cual es la mecánica a seguir para añadir 
una llamada al sistema y comprobar si debido funcionamiento.

Nos interesa aprender cómo crear llamadas al sistema con riscv, por lo tanto analizaremos los ficheros
básicos para la creación de estas llamadas y después añadiremos nosotros una nueva.

La llamada que vamos a implementar se llama int getprocs(void). Lo que hará esta función es devolver el número de procesos 
existentes en el sistema en el momento de la llamada.


2.

Por lo general, cuando se pretende añadir una llamada al sistema, se modifican los siguientes ficheros: syscall.h, syscall.c, sysproc.c,
proc.c, user.h, defs.h, usys.S. Iremos uno por uno, siguiendo el ejemplo de las demás funciones implementadas.


>>SYSCALL.h

// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_getprocs 22

Simplemente, añadimos una nueva entrada para la llamada.

>>SYSCALL.c

extern uint64 sys_chdir(void);
extern uint64 sys_close(void);
extern uint64 sys_dup(void);
extern uint64 sys_exec(void);
extern uint64 sys_exit(void);
extern uint64 sys_fork(void);
extern uint64 sys_fstat(void);
extern uint64 sys_getpid(void);
extern uint64 sys_kill(void);
extern uint64 sys_link(void);
extern uint64 sys_mkdir(void);
extern uint64 sys_mknod(void);
extern uint64 sys_open(void);
extern uint64 sys_pipe(void);
extern uint64 sys_read(void);
extern uint64 sys_sbrk(void);
extern uint64 sys_sleep(void);
extern uint64 sys_unlink(void);
extern uint64 sys_wait(void);
extern uint64 sys_write(void);
extern uint64 sys_uptime(void);
extern uint64 sys_getprocs(void);

static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_getprocs] sys_getprocs
};

Como vemos en esta situación, además de añadir una entrada al array de punteros a las funciones, debemos indicar al compilador que la función se encuentra definida en otro fichero,
al igual que el resto de funciones. Con uint indicamos que la función devuleve un dato de tipo unsigned int de 64 bits (8bytes).



>>SYSPROC.c

uint64
sys_getprocs (void)
{
  return getprocs(void);
}

En este fichero, definimos el wrapper de la función que realmente implementa la llamada, en proc.c



>>PROC.C

int 
getprocs (void)
{
  int counter  = 0;
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state != UNUSED) {
      counter++;
    }
    release(&p->lock);
  }

  return counter;
}


La primera gran diferencia que podemos observar en riscv es que no existe una tabla de procesos como tal. Lo que hay simplemente es un array
de ellos. Cuando necesitemos acceder a cada uno, entonces tomamos el lock del proprio proceso y al acabar de tratar con él lo soltamos.




>>USER.h


// system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);
int getprocs (void);

Estas son las funciones que aparecen visibles para el usuario.



>>DEFS.h


// proc.c
int             cpuid(void);
void            exit(int);
int             fork(void);
int             growproc(int);
void            proc_mapstacks(pagetable_t);
pagetable_t     proc_pagetable(struct proc *);
void            proc_freepagetable(pagetable_t, uint64);
int             kill(int);
struct cpu*     mycpu(void);
struct cpu*     getmycpu(void);
struct proc*    myproc();
void            procinit(void);
void            scheduler(void) __attribute__((noreturn));
void            sched(void);
void            sleep(void*, struct spinlock*);
void            userinit(void);
int             wait(uint64);
void            wakeup(void*);
void            yield(void);
int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
void            procdump(void);
int             getprocs (void);

Aquí se indica dónde están definidas las llamadas



>>USYS.S



Originalmente en este fichero en x86, había una macro que hacía saltar una interrupción para el tratamiento de la llamda al sistema.


# generated by usys.pl - do not edit
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
.global exit
exit:
 li a7, SYS_exit
 ecall
 ret
.global wait
wait:
 li a7, SYS_wait
 ecall
 ret
.global pipe
pipe:
 li a7, SYS_pipe
 ecall
 ret

 [...]


 Lo que vemos son una serie de instrucciones en ensamblador asociadas a cada una de las llamadas al sistema que existen.
 Este fichero en ensamblador lo produce otro fichero llamado usys.pl, en este es donde debemos hacer nuestras modificaciones.




 >>USYS.pl

Este fichero ya nos dice que usys.S, genera los stubs para las syscalls. Debemos crear una entrada más en la lista para 
nuestra llamada:


#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}
	
entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("getprocs");


Llegados a este punto, lo que nos interesa es poder probar la llamada al sistema con un programa de usuario. Para esto, escogeremos un programa de prueba para
fijarnos en cúal es la sintaxis que debemos seguir para poder hacer esto correctamente.

Destacaremos algunos aspectos que cambian con los programas de usuario:
    -los include: No es suficiente con poner solo el nombre, es necesario incluir la ruta a dicho archivo:
        #include "kernel/types.h"
        #include "kernel/stat.h"
        #include "user/user.h"
    
    -los exit: Además de usar exit(), como finalización del programa, le añadiremos un argumento que será el código de finalización. Si acaba bien, será exit (0).
    En otro caso, será exit(1);

    -los printf: en x86, se precedía un 1 al mensaje, para indicar que va a la salida estándar. En nuestro caso para riscv, solo ponemos el mensaje.
        printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);


Por lo demás, la sintaxis es igual. Ahora, veremos cómo hacer para compilar estos programas de usuairo.
Para empezar, todos los programas que sean de usuario se encuentran en la carpeta user. Para poderlo compilar,
debemos añadir su entrada correspondiente en el Makefile. 

UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_tester\
	$U/_getprocs\

Como es habitual, se añade la entrada en UPROGS.

Ahora, solo nos queda crear el fichero de prueba y probar la llamada :)

#include "kernel/types.h"
#include "user/user.h"


int main (void)
{
    //mostramos por pantalla el retorno de la llamada al sistema.
    printf ("El número de procesos existentes en el sistema es: %d\n", getprocs());
    return exit (0);
}

El resultado de la llamada es este:

xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$ ls
.              1 1 1024
..             1 1 1024
README         2 2 2226
cat            2 3 23600
echo           2 4 22432
forktest       2 5 13216
grep           2 6 26760
init           2 7 23256
kill           2 8 22360
ln             2 9 22232
ls             2 10 25768
mkdir          2 11 22488
rm             2 12 22472
sh             2 13 40488
stressfs       2 14 23472
usertests      2 15 150184
grind          2 16 36968
wc             2 17 24576
zombie         2 18 21744
tester         2 19 21928
getprocs       2 20 21808
console        3 21 0
$ getprocs
El número de procesos existentes en el sistema es: 3
$ 





