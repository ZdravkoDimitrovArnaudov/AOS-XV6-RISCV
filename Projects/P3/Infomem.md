## Address Spaces

xv6 ensures that each process can only read and write the memory that xv6 has allocated to it, and not for example the kernel’s memory or the memory of other processes. xv6 also arranges for each process’s memory to be contiguous and to start at virtual address zero. The C language definition and the Gnu linker expect process memory to be contiguous. Process memory starts at zero because that is traditional. A process’s view of memory is called an address space.

x86 protected mode defines three kinds of addresses. Executing software uses virtual addresses when fetching instructions or reading and writing memory. The segmentation hardware translates virtual to linear addresses. Finally, the paging hardware (when enabled) translates linear to physical addresses. Software cannot directly use a linear or physical address. xv6 sets up the segmentation hardware so that virtual and linear addresses are always the same: the segment descriptors all have a base of zero and the maximum possible limit. xv6 sets up the x86 paging hardware to translate (or "map") linear to physical addresses in a way that implements process address spaces with the properties outlined in the previous paragraph.

The paging hardware uses a page table to translate linear to physical addresses. A page table is logically an array of 2^20 (1,048,576) page table entries (PTEs). Each PTE contains a 20-bit physical page number (PPN) and some flags. The paging hardware translates a linear address by using its top 20 bits to index into the page table to find a PTE, and replacing those bits with the PPN in the PTE. The paging hardware copies the low 12 bits unchanged from the linear to the translated physical address. Thus a page table gives the operating system control over linear-to-physical address translations at the granularity of aligned chunks of 4096 (2^12) bytes.
Each PTE contains flag bits that tell the paging hardware to restrict how the associated linear address is used. PTE_P controls whether the PTE is valid: if it is not set,
a reference to the page causes a fault (i.e. is not allowed). PTE_W controls whether instructions are allowed to issue writes to the page; if not set, only reads and instruction fetches are allowed. PTE_U controls whether user programs are allowed to use the page; if clear, only the kernel is allowed to use the page.

A few notes about terms. Physical memory refers to storage cells in DRAM. A byte of physical memory has an address, called a physical address. A program uses virtual addresses, which the segmentation and paging hardware translates to physical addresses, and then sends to the DRAM hardware to read or write storage. At this level of discussion there is no such thing as virtual memory, only virtual addresses. Because xv6 sets up segments to make virtual and linear addresses always identical, from now on we’ll stop distinguishing between them and use virtual for both.

xv6 uses page tables to implement process address spaces as follows. Each process has a separate page table, and xv6 tells the page table hardware to switch page tables when xv6 switches between processes. A process’s memory starts at virtual address zero and can have size of at most 640 kilobytes (160 pages). xv6 sets up the PTEs for the process’s virtual addresses to point to whatever pages of physical memory xv6 has allocated for the process’s memory, and sets the PTE_U, PTE_W, and PTE_P flags in these PTEs. If a process has asked xv6 for less than 640 kilobytes, xv6 will leave PTE_P clear in the remainder of the first 160 PTEs.
Different processes’ page tables translate the first 160 pages to different pages of physical memory, so that each process has private memory. However, xv6 sets up every process’s page table to translate virtual addresses above 640 kilobytes in the same way. To a first approximation, all processes’ page tables map virtual addresses above 640 kilobytes directly to physical addresses, which makes it easy to address physical memory. However, xv6 does not set the PTE_U flag in the PTEs above 640 kilobytes, so only the kernel can use them. For example, the kernel can use its own instructions and data (at virtual/physical addresses starting at one megabyte). The kernel can also read and write the physical memory beyond the end of its data segment.

Every process’s page table simultaneously contains translations for both all of the process’s memory and all of the kernel’s memory. This setup allows system calls and interrupts to switch between a running process and the kernel without having to switch page tables. For the most part the kernel does not have its own page table; it is almost always borrowing some process’s page table. The price paid for this convnience is that the sum of the size of the kernel and the largest process must be less than four gigabytes on a machine with 32-bit addresses.

To review, xv6 ensures that each process can only use its own memory, and that a process sees its memory as having contiguous virtual addresses. xv6 implements the first by setting the PTE_U bit only on PTEs of virtual addresses that refer to the process’s own memory. It implements the second using the ability of page tables to translate a virtual address to a different physical address.

## Memory allocation

xv6 needs to allocate physical memory at run-time to store its own data structures and to store processes’ memory. There are three main questions to be answered
when allocating memory. First, what physical memory (i.e. DRAM storage cells) are to be used? Second, at what virtual address or addresses is the newly allocated physical memory to be mapped? And third, how does xv6 know what physical memory is free and what memory is already in use?

xv6 maintains a pool of physical memory available for run-time allocation. It uses the physical memory beyond the end of the loaded kernel’s data segment. xv6 allocates (and frees) physical memory at page (4096-byte) granularity. It keeps a linked list of free physical pages; xv6 deletes newly allocated pages from the list, and adds freed pages back to the list.
When the kernel allocates physical memory that only it will use, it does not need to make any special arrangement to be able to refer to that memory with a virtual address: the kernel sets up all page tables so that virtual addresses map directly to physical addresses for addresses above 640 KB. Thus if the kernel allocates the physical page at physical address 0x200000 for its internal use, it can use that memory via virtual address 0x200000 without further ado.

What if a process allocates memory with sbrk? Suppose that the current size of the process is 12 kilobytes, and that xv6 finds a free page of physical memory at physical address 0x201000. In order to ensure that process memory remains contiguous, that physical page should appear at virtual address 0x3000 when the process is running. This is the time (and the only time) when xv6 uses the paging hardware’s ability to translate a virtual address to a different physical address. xv6 modifies the 3rd PTE (which covers virtual addresses 0x3000 through 0x3fff) in the process’s page table to refer to physical page number 0x201 (the upper 20 bits of 0x201000), and sets PTE_U, PTE_W, and PTE_P in that PTE. Now the process will be able to use 16 kilobytes of contiguous memory starting at virtual address zero. Two different PTEs now refer to the physical memory at 0x201000: the PTE for virtual address 0x201000 and the PTE for virtual address 0x3000. The kernel can use the memory with either of these addresses; the process can only use the second.

## Code: Memory allocator

The xv6 kernel calls kalloc and kfree to allocate and free physical memory at run-time. The kernel uses run-time allocation for process memory and for these kernel data strucures: kernel stacks, pipe buffers, and page tables. The allocator manages page-sized (4096-byte) blocks of memory.
The allocator maintains a free list of addresses of physical memory pages that are available for allocation. Each free page’s list element is a struct run (2360). Where does the allocator get the memory to hold that data structure? It store each free page’s run structure in the free page itself, since there’s nothing else stored there. The free list is protected by a spin lock (2360-2362). The list and the lock are wrapped in a struct to make clear that the lock protects the fields in the struct. For now, ignore the lock and the calls to acquire and release; Chapter 4 will examine locking in detail.
Main calls kinit to initialize the allocator (2371). kinit ought to determine how much physical memory is available, but this turns out to be difficult on the x86. Instead it assumes that the machine has 16 megabytes (PHYSTOP) of physical memory,
and uses all the memory between the end of the kernel and PHYSTOP as the initial pool of free memory. kinit uses the symbol end, which the linker causes to have an address that is just beyond the end of the kernel’s data segment.
Kinit (2371) calls kfree with the address of each page of memory between end and PHYSTOP. This will cause kfree to add those pages to the allocator’s free list. A PTE can only refer to a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so kinit uses PGROUNDUP to ensure that it frees only aligned physical addresses. The allocator starts with no memory; these initial calls to kfree gives it some to manage.
Kfree (2405) begins by setting every byte in the memory being freed to the value 1. This will cause code that uses memory after freeing it (uses "dangling references") to read garbage instead of the old valid contents; hopefully that will cause such code to break faster. Then kfree casts v to a pointer to struct run, records the old start of the free list in r->next, and sets the free list equal to r. Kalloc removes and returns the first element in the free list.

## Code: Page Table Initialization ##

mainc (1354) creates a page table for the kernel’s use with a call to kvmalloc, and mpmain (1380) causes the x86 paging hardware to start using that page table with a call to vmenable. This page table maps most virtual addresses to the same physical address, so turning on paging with it in place does not disturb execution of the kernel.
kvmalloc (2576) calls setupkvm and stores a pointer to the resulting page table in kpgdir, since it will be used later.
An x86 page table is stored in physical memory, in the form of a 4096-byte "page directory" that contains 1024 PTE-like references to "page table pages." Each page table page is an array of 1024 32-bit PTEs. The paging hardware uses the top 10 bits of a virtual address to select a page directory entry. If the page directory entry is marked PTE_P, the paging hardware uses the next 10 bits of the virtual address to select a PTE from the page table page that the page directory entry refers to. If either of the page directory entry or the PTE has no PTE_P, the paging hardware raises a fault. This two-level structure allows a page table to omit entire page table pages in the common case in which large ranges of virtual addresses have no mappings.
setupkvm allocates a page of memory to hold the page directory. It then calls mappages to install translations for ranges of memory that the kernel will use; these translations all map each virtual address to the same physical address. The translations include the kernel’s instructions and data, physical memory up to PHYSTOP, and memory ranges which are actually I/O devices. setupkvm does not install any mappings for the process’s memory; this will happen later.
mappages (2531) installs mappings into a page table for a range of virtual addresses to a corresponding range of physical addresses. It does this separately for each virtual address in the range, at page intervals. For each virtual address to be mapped, mappages calls walkpgdir to find the address of the PTE that should the address’s translation. It then initializes the PTE to hold the relevant physical page number, the desired permissions ( PTE_W and/or PTE_U), and PTE_P to mark the PTE as valid (2542).
4
walkpgdir (2504) mimics the actions of the x86 paging hardware as it looks up the PTE for a virtual address. It uses the upper 10 bits of the virtual address to find the page directory entry (2510). If the page directory entry isn’t valid, then the required page table page hasn’t yet been created; if the create flag is set, walkpgdir goes ahead and creates it. Finally it uses the next 10 bits of the virtual address to find the address of the PTE in the page table page (2524). The code uses the physical addresses in the page directory entries as virtual addresses. This works because the kernel allocates page directory pages and page table pages from an area of physical memory (between the end of the kernel and PHYSTOP) for which the kernel has direct virtual to physical mappings.
vmenable (2602) loads kpgdir into the x86 %cr3 register, which is where the hardware looks for the physical address of the current page directory. It then sets CR0_PG in %cr0 to enable paging.


[xv6 Zoo](http://zoo.cs.yale.edu/classes/cs422/2011/xv6-book/mem.pdf)
