-------------------------------------------
-MEMORIA P2: Planificador por prioridades--
-------------------------------------------

Indice  
    1.  Objetivos
    2.  Planteamiento y desarrollo 
    3.  Observaciones de la práctica


1. 

La práctica actual fue resuelta en x86. Parto de los conocimientos aprendidos anteriormente, con lo cual no se detallarán en gran medida 
los pasos tomados para resolver este ejercicio en riscv. Sin embargo, todo lo que se considere necesario nombrar aparecerá en esta memoria.

2.

Esta parte de la memoria se está escribiendo después de haber finalizado satisfactoriamente la práctica. Con lo cual, abordaremos simplemente los aspectos más importantes a destacar,
los problemas que nos salieron y cómo los solucionamos.

Empezaremos primero con las llamadas al sistema. Una de las diferencias fundamentales entre x86 y riscv con las syscalls es la comunicación userspace y kernelspace. Estos espacios 
ya no están juntos, entonces tenemso que hacernos de otros medios para comunicar ambas partes. Para ello, tenemos funciones llamadas "copyin" y "copyout". En el caso de getpinfo, hay una estructura
"inicializada" en espacio de usuario que debe ser "completada" por el kernel. Para poder hacer esto, el kernel crea su propia instancia de la estructua, la completa con los datos convenientes y al terminar,
accede a la tabla de páginas del proceso y escribe dicha estructura, en la instanciada en espacio de usuario.

Por lo general, la implementación de las llamadas al sistema no cambian demasiado, a excepción de algunos detalles mínimos en algunos ficheros. Por ejemplo, existen un fichero usys.pl que antes no se modificaba 
en x86. 

La complejidad más grande de esta práctica reside en cómo se implementa el planificador en proc.c. En riscv, a diferencia de x86, no existe una tabla de procesos que se pueda recorrer y aplicar un lock.
Nosotros tenemos una sola lista de procesos y los locks son internos para cada proceso. Por este motivo, no podemos aspirar a una implementación sencilla como en x86. Si quisiésemos hacer eso, tendríamos que adquirir y 
liberar locks constantemente y rezando para que no suceda algo de por medio.

Una solución a esto, podría ser replicar la tabla de procesos que se usa en x86 y añadirle un lock a dicha tabla. El problema de esta opción es que estamos renunciando a cómo está implementado riscv en sí,
por algún motivo lo habrán hecho de esta forma. La alternativa por la que hemso optado, es definir una variable global que muestre en cada momento el número de procesos de alta prioridad corriendo en el sistema.
De esta forma, nuestro planificador se simplifica solo a una condición IF. Es imprescindible tener en mente que los procesos también pasan por otros estados y que por ese motivo, la variable tiene que ser actualizada en consecuencia.
Entonces, en funciones como sleep o wakeup por ejemplo, habrá que hacer esa modificación. También, recordar que el acceso a dicha variable debe ser protegido en todo momento por locks.


Al ejecutar los test, nos han salido muchas veces problemas con usertraps. Además, se sabe que es algo conocido (ver cabecera usertests). El problema estaba en los test. Algunos de ellos, fallaban porque no se estaba reservando 
espacio para aquellas estructuras en las que escribe el kernel. Por eso, en lugar de emplear la dirección de memoria de variables, hemos creado punteros y reservado memoria dinámica con malloc antes de llamar 
a getpinfo. Así, se solucionan.

