-------------------------------------------
-MEMORIA P2: Planificador por prioridades--
-------------------------------------------

Indice  
    1.  Objetivos
    2.  Planteamiento y desarrollo 
    3.  Observaciones de la práctica


1. 

La práctica actual fue resuelta en x86. Parto de los conocimientos aprendidos anteriormente, con lo cual no se detallarán en gran medida 
los pasos tomados para resolver este ejercicio en riscv. Sin embargo, todo lo que se considere necesario nombrar aparecerá en esta memoria.

2.

El primer acercamiento a esta práctica, será crear la llamada al sistema getpinfo y hacerla funcional. Para probarla, crearemos un 
programa de usuario llamado ps.c que comprobará su funcionamiento.

>>GETPINFO 


Antes que nada, como ya sabemos, la llamada al sistema getpinfo, recibe "un puntero" a una estructura declada en userspace que el kernel 
accederá y completará con los datos correspondientes. Comenzaremos primero con la estructura y luego con la llamada en sí.

Por lo tanto, creamos el fichero pstat.h en la carpeta kernel:

#ifndef _PSTAT_H_
#define _PSTAT_H_

#include "param.h"

struct pstat {
    int inuse[NPROC];  // whether this slot of the process process table is in use (1 or 0)
    int pid[NPROC];    // the PID of each process
    int hticks[NPROC]; // the number of ticks each process has accumulated at priority 2
    int lticks[NPROC]; // the number of ticks each process has accumulated at priority 1
};

#endif // _PSTAT_H_



Más adelante esta declaración nos da problemas al probar la llamada al sistema. Es porque no son int sino uint64, es decir:

#ifndef _PSTAT_H_
#define _PSTAT_H_

#include "param.h"

struct pstat {
    uint64 inuse[NPROC];  // whether this slot of the process process table is in use (1 or 0)
    uint64 pid[NPROC];    // the PID of each process
    uint64 hticks[NPROC]; // the number of ticks each process has accumulated at priority 2
    uint64 lticks[NPROC]; // the number of ticks each process has accumulated at priority 1
};

#endif // _PSTAT_H_




Además, esta estructura debe estar definida en:
    -defs.h:
        struct buf;
struct context;
struct file;
struct inode;
struct pipe;
struct proc;
struct spinlock;
struct sleeplock;
struct stat;
struct superblock;
struct pstat;

    -user.h:
        struct stat;
    struct rtcdate;
    struct pstat;  

    -proc.C
        #include "pstat.h"

Como ya sabemos, para la llamada al sistema, tendremos que modificar los ficheros: syscall.h, syscall.c, sysproc.c, proc.c, defs.h, user.h, usys.pl.
Iremos uno por uno añadiendo lo que hiciese falta.

    #SYSCALL.H 

// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_getpinfo 22

    #SYSCALL.C 



extern uint64 sys_chdir(void);
extern uint64 sys_close(void);
extern uint64 sys_dup(void);
extern uint64 sys_exec(void);
extern uint64 sys_exit(void);
extern uint64 sys_fork(void);
extern uint64 sys_fstat(void);
extern uint64 sys_getpid(void);
extern uint64 sys_kill(void);
extern uint64 sys_link(void);
extern uint64 sys_mkdir(void);
extern uint64 sys_mknod(void);
extern uint64 sys_open(void);
extern uint64 sys_pipe(void);
extern uint64 sys_read(void);
extern uint64 sys_sbrk(void);
extern uint64 sys_sleep(void);
extern uint64 sys_unlink(void);
extern uint64 sys_wait(void);
extern uint64 sys_write(void);
extern uint64 sys_uptime(void);
extern uint64 sys_getpinfo(void);



static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_getpinfo] sys_getpinfo
};


    #SYSPROC.C 

uint64
sys_getpinfo(void)
{
  uint ps;

  //obtenemos puntero
  if (argaddr(0, &ps) < 0){
    return -1;
  }

  if (ps == NULL){ //NULL
    return -1;
  }
  
  return getpinfo (ps);;
}

En principio es la primera versión que tenemos, hay varias cosas a destacar.
    -Para empezar, recordar que en riscv el userspace y kernelspace están separados en discos distintos. Por este motivo, tendremos que hacer las cosas de distinta forma.
El planteamiento general es generar un puntero mediante la función argaddr y pasársela a getpinfo en proc.c. Si la función 
argaddr falla o el puntero es null, se devuelve -1. 

¿En qué se diferencia de la versión en x86?
creamos un puntero unsigned int de 64 bits (8 bytes), no un puntero a una estructura pstat que luego se pasa como parametro.



    #PROC.C 


int 
getpinfo (uint addr){

  //debemos definir al proceso proc y la estructura pstat.
  struct proc *p;
  struct pstat ps;
  uint counter = 0;


  for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state != UNUSED) {
        ps.inuse[counter] = 1;
        ps.pid[counter] = p->pid;
        ps.hticks[counter] = p->hticks;
        ps.lticks[counter] = p->lticks; 
      }
      counter++;
      release(&p->lock);
    }

    p = myproc(); //calling process

    //la estuctura que hemos completado, se copiará desde la tabla de paginas del proceso a la estructura pstat que ha inicializado
    if (copyout (p->pagetable, addr, (char *)&ps, sizeof (ps)) < 0){
      return -1;
    }

  return 0;
}


El primer acercamiento que tomaremos de la implementación es la siguiente. Lo que hacemos es recorrer el array de procesos
y compeltar la estructura pstat que hemos instanciado. Cuando acabemos, recogemos al proceso actual e indicamos 
que dicha tabla, la copie en la tabla de paginas del propio proceso donde se encuentre su propia estructura pstat instanciada.


Cabe destacar, que en la librería proc.h hemos añadido tres campos más al proceso, que son la prioridad,
y los ticks en alta y baja prioridad. 
  
  int priority;                // priority 
  uint64 hticks;               // clock ticks at high priority
  uint64 lticks;               // clock ticks at low priority 


También, tenemos que iniciarlos en allocproc en proc.C:

found:
  p->pid = allocpid();
  p->state = USED;

  //añadimos campos
  p->priority = LOW_PRIORITY;
  p->hticks = 0;
  p->lticks = 0;




    #USYS.pl

entry("getpinfo");





A estas altuas, podríamos intentar probar el funcionamiento operativo de la llamada al sistema 
desde un programa de usuario. Deberían mostrarse los PID de los procesos existentes en el sistema pero no 
los ticks, ya que aún no hemos modificado el planificador.

Entonces, creamos un programa de usuario ps.c:

#include "../kernel/types.h"
#include "user.h"
#include "../kernel/pstat.h"


int main (void)
{
    struct pstat ps;
    if (getpinfo(ps) < 0){
        printf ("ERROR. La llamada ha devuelto codigo -1\n");
        exit(1);
    }

    for (int i = 0; i < NPROC; i++){
        if (ps.inuse[i]){
            printf ("PID:   %d; LTICKS:     %d; HTICKS:     %d\n", ps.pid[i], ps.lticks[i], ps.hticks[i]);   
        }
    }

    exit(0);
}

Para que funcione, lo compilamos en Makefile y probamos el programa:

xv6 kernel is booting

init: starting sh
$ ps
PID:   1; LTICKS:     0; HTICKS:     0
PID:   2; LTICKS:     0; HTICKS:     0
PID:   3; LTICKS:     0; HTICKS:     0
$ 


Llegados a este punto, podríamos comenzar implementando la segunda llamada al sistema y el planificador finalmente.



>>SETPRI
De nuevo, modificamos aquellos ficheros necesarios para implementar la llamada al sistema:

    #SYSCALL.H 

    // System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_getpinfo 22
#define SYS_setpri 23


    #SYSCALL.c


extern uint64 sys_chdir(void);
extern uint64 sys_close(void);
extern uint64 sys_dup(void);
extern uint64 sys_exec(void);
extern uint64 sys_exit(void);
extern uint64 sys_fork(void);
extern uint64 sys_fstat(void);
extern uint64 sys_getpid(void);
extern uint64 sys_kill(void);
extern uint64 sys_link(void);
extern uint64 sys_mkdir(void);
extern uint64 sys_mknod(void);
extern uint64 sys_open(void);
extern uint64 sys_pipe(void);
extern uint64 sys_read(void);
extern uint64 sys_sbrk(void);
extern uint64 sys_sleep(void);
extern uint64 sys_unlink(void);
extern uint64 sys_wait(void);
extern uint64 sys_write(void);
extern uint64 sys_uptime(void);
extern uint64 sys_getpinfo(void);
extern uint64 sys_setpri(void);



static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_getpinfo] sys_getpinfo,
[SYS_setpri]  sys_setpri
};


    #SYSPROC.C

uint64
sys_setpri(void)
{
  int num;
  if(argint(0, &num) < 0){
    return -1;
  }

  if (num < 1 || num > 2){
    return -1;
  }

  setpri(num); //cambiamos la prioridad al proceso
  return 0;
}


    #proc.C

Para esta implementación, además de modificar la prioridad del proceso, accederemos a una variable global para hacer
saber al planificador si hay procesos con prioridad alta o no por ejecutarse.



void
setpri (int num)
{
  struct proc *p = myproc();
  acquire(&p->lock);
  if (p->state == LOW_PRIORITY && num == HIGH_PRIORITY){ //solo si el proceso pasa de prioridad baja a alta
    high_priority_procs++;
  } else if (p->state == HIGH_PRIORITY && num == LOW_PRIORITY){
    high_priority_procs--;
  }
    p->priority = num;
  
  release(&p->lock);
}


    #DEFS.H

// proc.c
int             cpuid(void);
void            exit(int);
int             fork(void);
int             growproc(int);
void            proc_mapstacks(pagetable_t);
pagetable_t     proc_pagetable(struct proc *);
void            proc_freepagetable(pagetable_t, uint64);
int             kill(int);
struct cpu*     mycpu(void);
struct cpu*     getmycpu(void);
struct proc*    myproc();
void            procinit(void);
void            scheduler(void) __attribute__((noreturn));
void            sched(void);
void            sleep(void*, struct spinlock*);
void            userinit(void);
int             wait(uint64);
void            wakeup(void*);
void            yield(void);
int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
void            procdump(void);
int             getpinfo (uint64 addr);
void            setpri(int num);


    #USER.H

/ system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);
int getpinfo(struct pstat *);
int setpri(int num);

    #USYS.H

	
entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("getpinfo");
entry("setpri");


Ya tendríamos la segunda llamada al sistema hecha. Lo que nos faltaría es implementar el planificador y correr los test.