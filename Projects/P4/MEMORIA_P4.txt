---------------------
------MEMORIA P4-----
---------------------

Indice
    1. Objetivos
    2. Planteamiento
    3. Desarrollo
    4. Observaciones


1.

El objetivo de esta práctica consiste en poder añadir correctamente kernel threads.
Necesitamos realizar 3 cosas:
    -añadir una llamada al sistema que genere kernel threads, llamada clone() y otra que haga wait al thread con la llamada join().
    -usar clone() para construir una librería de thread (en espacio de usuario) con llamadas thread_create() y thread_join();
    -soporte para locks y variables condicionales.
        +para locks: lock_init(), lock_acquire(), lock_release()
        +para variables condicionales: cv_init(), cv_wait(), cv_signal().



2.

El prototipo de la llamada al sistema clone, deberá ser:
    int clone (void(*fcn)(void*), void *arg, void*stack);

Esta llamada crea un nuevo kernel thread que comparte el espacio de direcciones del proceso que lo crea.
El nuevo thread/proceso emplea "stack" como su stack de usuario. Tendrá el tamaño de una página 
y deberá estar alineada. El nuevo proceso, comienza ejecutando en la dirección indicada por el puntero fcn. 
Al igual que el fork(), al final el PID del nuevo thread se comparte con el padre.


La segunda nueva llamada al sistema es join(void **stack). Esta syscall, espera a que termine el proceso hijo
que comparte el espacio de direcciones del proceso padre. Devuelve el PID del hijo esperado, o -1 si no existe.
La localización del stack de usuario del hijo está copiado en el argumento "stack".

Es necesario también pensar en cómo gestionar algunas llamadas al sistema existentes como wait y exit.
Para wait, ¿será necesario esperar a un proceso hijo que no comparte el espacio de direcciones del padre?
Para exit(), debe funcionar como antes. Para ambos procesos y threads se deberán hacer pocos cambios.

>>LIBRERÍA DE THREAD 

La librería de thread, deberá componer la llamada thread_create (void *start_routine)(void*), void *arg).
Esta rutina tendrá que llamar a malloc() para crear el nuevo userstack, usar clone() para poder crear el thread hijo y ponerlo
a ejecutar. Una llamada thread_join() también deberá ser usada, que emplea la llamada join del sistema, libera el user stack y luego devuelve.

La librería de thread, también deberá tener un simple spinlock. Tiene que haberun tipo lock_t que uno emplea para declarar un
lock y dos rutinas: lock_acquire(lock_t*) y lock_release(lock_t*), que adquieren y  liberan el lock.
También, lock_init(lock_t *) nos servirá para inicializar el lock.

Finalmente, deberemos tener una variable condicional y las respectivas rutinas: cond_t, cv_wait (cond_t*, lock_t*)
y cv_signal(cond_t*). Estas rutinas deberían hacer lo esperado: poner al llamante a dormir (y liberar el lock) o despertar 
al thread dormido respectivamente. Deberán añadirse llamadas al sistema adicionales para cumplir con esto.
Dejalo para el final del proyecto.

Para probar el código, usar los test. También, es recomendable crear pequeñas piezas de código para comprobar 
que todo funciona.


>>RESUMEN

El objetivo esencial es generar una librería de thread para el espacio de usuairo. Esta librería compone una serie de funciones que aportan gestión de threads,
locks y variables condicionales. 

En cuanto a los threads, existen dos llamadas que pueden hacerse: thread_create y thread_join. La primera de ellas hará uso de la llamada clone() y la segudna de join(). Para la implementación
de clone(), podemos observar el comportamiento de fork(), pues debemos hacer que este proceso comparta el espacio de direcciones del proceso padre, pero su stack será distinto.

De cara a los locks, saber que debemos inicializar, acquire y release. Para esto, podemos basarnos en la implementación del spinlock, acquire y realease implementados.
Sobre las variables condicionales, lo dejaremos para el final.



3.


Inicialmente, lo que haremos será estructurar la librería de threads. 
Para poder definir estas funciones, necesitamos un tipo de dato lock_t. Este lo vamos a definir en user.h como typedef uint lock_t.

Nuestro primer objetivo es completar la funcionalidad thread_create. Esta llamada lo que deberá hacer es llamar a malloc() para crear 
el stack de usuario que empleará el thread (destacamos que su stack se situará en el heap del proceso padre). Después, se empleará la llamada al sistema 
clone() para crear el proceso hijo y ejecutarlo.

El stack tiene tamaño de una página y además la dirección virtual debe estar alineada a página.
Esto quiere decir que si hacemos va %  PGSIZE, nos debe dar cero (ejemplo en vmc, uvmunmap()). Si nos da distinto, significa que no está alineada y por tanto debemos hacerlo.
Para poder hacer esto, ampliamos la dirección hasta que se pueda alinear a pagina: stack = stack + (PAGE_SIZE - (va % PGSIZE)).

De esta forma, la función queda así:

int thread_create(void (*start_routine)(void*),  void *arg){
    
    uint64 va;

    //creamos el stack del thread con tamaño de pagina 1
    void *stack;
    if (!(stack = malloc (PAGE_SIZE))){
        printf ("Error: No se ha podido allocatar el stack en el heap del proceso padre.\n");
        return -1;
    }

    //comprobamos si la dirección está alineada a página. En caso contrario hacerlo.
    va = (uint64) stack;
    if ((va % PAGE_SIZE) != 0){
        stack = stack + (PAGE_SIZE - (va % PAGE_SIZE));
    }
    
    return clone (start_routine, arg, stack);
}


Vamos a proceder a crear la llamada al sistema clone(). Como ya sabemos, modificaremos los ficheros típicos.

>>SYSCALL.h

// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_clone 22

>>SYSCALL.c 

//...

extern uint64 sys_wait(void);
extern uint64 sys_write(void);
extern uint64 sys_uptime(void);
extern uint64 sys_clone (void);

static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_clone]   sys_clone
};



>>USYS.Pl 

entry("clone");


>>USER.h

// system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);
int clone(void(*fcn)(void*), void *arg, void*stack);

>>SYSPROC.C 

uint64
sys_clone (void)
{
  void *stack;
  void *arg;
  void *fcn;

   //obtenemos puntero función
   if(argaddr(0, &fcn) < 0){
     return -1;
   }

   //obtenemos puntero a argumento de función
   if(argaddr(1, &arg) < 0){
     return -1;
   }

   //obtenemos putnero a stack de usuario
   if(argaddr(2, &stack) < 0){
     return -1;
   }
   
  return clone(fcn, arg, stack);
}


>>DEFS.h

// proc.c
int             cpuid(void);
void            exit(int);
int             fork(void);
int             growproc(int);
void            proc_mapstacks(pagetable_t);
pagetable_t     proc_pagetable(struct proc *);
void            proc_freepagetable(pagetable_t, uint64);
int             kill(int);
struct cpu*     mycpu(void);
struct cpu*     getmycpu(void);
struct proc*    myproc();
void            procinit(void);
void            scheduler(void) __attribute__((noreturn));
void            sched(void);
void            sleep(void*, struct spinlock*);
void            userinit(void);
int             wait(uint64);
void            wakeup(void*);
void            yield(void);
int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
void            procdump(void);
int             clone(void(*fcn)(void*), void *arg, void*stack)

>>PROC.C 

La implementación de esta función es muy parecida a la de fork(). Con lo cual, copiamos y pegamos fork() en nuestra
función clone y aquí quitamos y eliminamos aquello que nos interese. 

Para empezar, lo que no nos interesa es copiar el espacio de direcciones del padre al hijo con uvmcopy, porque simplemente queremos compartirlo.
Entonces, hemos tenido que añadir una serie de cambios: 
  -copiado tabla de paginas al hijo, 
  -el program counter del hijo (registro epc) debe apuntar a la nueva función pasada por parámetro, 
  -hemos de recoger en el stack de usuario el argumento que se pasa y la dirección de retorno falsa y expandir
el stack consecuentemente, 
  -enviarlos cambios al stack de usuario con copyout, 
  -actualizar stackpointer después de los cambios.

  La función con la que nos hemos quedado es la siguiente:

int clone(void(*fcn)(void*), void *arg, void*stack)
{

    int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // Allocate process.
  if((np = allocproc()) == 0){
    return -1;
  }

  //Tenemos que copiar también al proceso hijo la tabla de páginas del proceso padre
  np->pagetable = p->pagetable;
  np->sz = p->sz;

  // copy saved user registers.
  *(np->trapframe) = *(p->trapframe);

  // Cause fork to return 0 in the child.
  np->trapframe->a0 = 0;

  /*
    -user_stack[2]: elementos que introducimos en la pila
        +argumento de función
        +PC de retorno falso
    -modificar stack pointer 
    -hacer que program counter apunte a la función
  */


  uint64 user_stack[2];
  user_stack[0] = (uint64) 0xffffffff; //PC retorno
  user_stack[1] = (uint64)arg; //cast uint64
  np->bottom_ustack = (uint64) stack;
  np->top_ustack = np->bottom_ustack + PGSIZE;
  np->top_ustack -= 8; //para incorporar al stack el argumento y retorno

  printf ("Antes de hacer copyout.\n");

  //copyout
  if (copyout(np->pagetable, np->top_ustack, (char *) user_stack, 8) < 0) {
        return -1;
    }

  printf ("Copyout correcto al stack del thread.\n");

  //cambiar program counter a la función que debe ejecutar
  np->trapframe->epc = (uint64) fcn;

  //actualiza stack pointer
  np->trapframe->sp = np->top_ustack;


  // increment reference counts on open file descriptors.
  for(i = 0; i < NOFILE; i++)
    if(p->ofile[i])
      np->ofile[i] = filedup(p->ofile[i]);
  np->cwd = idup(p->cwd);

  safestrcpy(np->name, p->name, sizeof(p->name));

  //para devolverlo
  pid = np->pid;

  //asignamos también al hijo las referencias que tiene el padre y sumamos al hijo
  np->referencias = p->referencias;
  np->referencias = np->referencias +1;

  release(&np->lock);

  //para registrar cual es su padre
  acquire(&wait_lock);
  np->parent = p;
  release(&wait_lock);

  //para cambiar su estado a ejecutable
  acquire(&np->lock);
  np->state = RUNNABLE;
  release(&np->lock);

  return pid;

}


Nuestro siguiente paso será continuar con la función de usuario thread_join() y join(void **stack).
En thread_join, simplemente hemos de recoger lo que devuelve la función join(), que es simplemente el PID del 
proceso hijo que ha terminado (tid en este caso) y devolverlo de nuevo. 

int thread_join()
{
    void *stack;
    int child_tid;
    if (child_tid = join(&stack) <0 ){
        free(stack);
        return -1;
    } //recibimos tid 

    return child_tid;
}

Por lo tanto, seguimos con la siguiente llamada al sistema que es join(void **stack).
Como siempre, modificamos los ficheros esenciales para poder incluirla.

>>SYSCALL.H

// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_clone 22
#define SYS_join 23


>>SYSCALL.C 

extern uint64 sys_join (void);


//...
extern uint64 sys_uptime(void);
extern uint64 sys_clone (void);
extern uint64 sys_join (void);

static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_clone]   sys_clone,
[SYS_join]    sys_join
};


>>USYS.Pl
entry("join");



>>SYSPROC.C 


uint64
sys_join (void)
{
  void **stack;
  if(argaddr(0, &stack) < 0){
     return -1;
  }

  return join (stack);
}


>>DEFS.H 

// proc.c
int             cpuid(void);
void            exit(int);
int             fork(void);
int             growproc(int);
void            proc_mapstacks(pagetable_t);
pagetable_t     proc_pagetable(struct proc *);
void            proc_freepagetable(pagetable_t, uint64);
int             kill(int);
struct cpu*     mycpu(void);
struct cpu*     getmycpu(void);
struct proc*    myproc();
void            procinit(void);
void            scheduler(void) __attribute__((noreturn));
void            sched(void);
void            sleep(void*, struct spinlock*);
void            userinit(void);
int             wait(uint64);
void            wakeup(void*);
void            yield(void);
int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
void            procdump(void);
int             clone(void(*fcn)(void*), void *arg, void*stack);
int             join (void **stack);


>>USER.h 

// system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);
int clone(void(*fcn)(void*), void *arg, void*stack);
int join (void **stack);


>>PROC.C 

De nuevo, la implementación no es muy distinta de wait(). En este caso, tenemos que liberar el user stack 
y devolver el PID del proceso o tid. Esto implica hacer que el stack indicado por parámetro apunte al userstack del usuario para poder 
liberarlo posteriormente en thread_join.

Cuando recorramos los procesos en join, esto lo haremos únicamente para aquel thread hijo cuyo padre sea el proceso que llama la función 
y además comparta su tabla de páginas, es decir el thead que estamos buscando.

En resumen, ¿Qué es lo que debe hacer el join?
    -copiar argumento stack a la dirección userstack del thread
    -en estado ZOMBIE del thread, hemos de limpiar los registros y campos adecuados. No podemos modificar todos tal y como hace la función freeproc,
    porque el thread comparte el espacio de direcciones y no puede liberar las paginas fisicas.
    -devolver el TID.


La primera implementación que tenemos de join con comentarios es esta:


int join (void **stack){

  struct proc *np;
  int havekids, pid;
  struct proc *p = myproc();

  acquire(&wait_lock);

  for(;;){
    // Scan through table looking for exited children.
    havekids = 0;
    for(np = proc; np < &proc[NPROC]; np++){
      if(np->parent == p && np->pagetable == p->pagetable){ //modificamos la condición para que se seleccione solo al thread hijo del proceso


        // make sure the child isn't still in exit() or swtch().
        acquire(&np->lock);

        havekids = 1;
        if(np->state == ZOMBIE){
          // Found one.

          //copiamos en el argumento stack la dirección del stack de usuario para que pueda liberarse después con free
          *stack = np->bottom_ustack; //Debe apuntar al principio o cabeza de stack?
          pid = np->pid;
          
          //creo que para wait de thread no es necesario?

         /*  if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
                                  sizeof(np->xstate)) < 0) {
            release(&np->lock);
            release(&wait_lock);
            return -1;
          } */
          

         //modificamos código de freeproc, ya que no debemos usar todo

          // if(p->trapframe)
          //   kfree((void*)p->trapframe);
          np->trapframe = 0;
          // if(p->pagetable)
          //   proc_freepagetable(p->pagetable, p->sz);

          np->pagetable = 0; //no modifica tabla de paginas del padre
          np->sz = 0; //no modifica sz del padre
          np->pid = 0; //lock tomado
          np->parent = 0;
          np->name[0] = 0;
          np->chan = 0; //?? no se que es, lock tomado
          np->killed = 0; //lock tomado
          np->xstate = 0; //lock está tomado
          np->state = UNUSED; //lock tomado

          
          //limpiamos top_stack?

          release(&np->lock); //libera thread
          release(&wait_lock);
          
          return pid; //devolvemos TID 
        }
        release(&np->lock);
      }
    }

    // No point waiting if we don't have any children.
    if(!havekids || p->killed){
      release(&wait_lock);
      return -1;
    }
    
    // Wait for a child to exit.
    sleep(p, &wait_lock);  //DOC: wait-sleep
  }

}


El siguiente paso ahora, será modificar algunas llamadas existentes:
    
    -wait(): esperar a un proceso hijo que no comparta el espacio de direcciones del proceso padre. También,
    liberar el espacio de direcciones si es el único proceso con referencia al mismo. Esto es, porque aunque un padre tenga un proceso hijo,
    el hijo también puede haber creado un thread y este compartiría el espacio de direcciones con él o con todos los threads que también tengan acceso a este.
      +para esto último, debemos implementar un campo que señale el número de referencias al espacio de direcciones!!!!

    -exit(): ahora el exit también deberá funcionar para procesos y threads, realmente poco cambio.



>>WAIT()

Como ya sabemos, hemos de esperar a aquellos procesos hijos que no compartan el espacio de direcciones (no sean threads).
Además, cuando esta sea la última referencia al espacio de direcciones, es necesario limpiar el espacio de direcciones también.

int
wait(uint64 addr)
{
  struct proc *np;
  int havekids, pid;
  struct proc *p = myproc();

  acquire(&wait_lock);

  for(;;){
    // Scan through table looking for exited children.
    havekids = 0;
    for(np = proc; np < &proc[NPROC]; np++){
      if(np->parent == p && np->pagetable != p->pagetable){ //Proceso hijo no puede compartir el espacio de direcciones el padre
        // make sure the child isn't still in exit() or swtch().
        acquire(&np->lock);

        havekids = 1;
        if(np->state == ZOMBIE && np->referencias == 1){ //tiene 
          // Found one.
          pid = np->pid;
          if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
                                  sizeof(np->xstate)) < 0) {
            release(&np->lock);
            release(&wait_lock);
            return -1;
          }
          freeproc(np);
          release(&np->lock);
          release(&wait_lock);
          return pid;
        }
        release(&np->lock);
      }
    }

También, debemos inicializar los campos nuevos en alloc:

//...
found:
  p->pid = allocpid();
  p->state = USED;

  //inicializamos campos nuevos
  p->bottom_ustack = 0;
  p->top_ustack = 0;
  p->referencias = 1;
//...



Ahora mismo estamos intentando pasar los tests de clone. Resulta que la función acaba bien, salvo 
la parte de entrar a ejecutar la función. Pensamos que es por la separación entre espacio de usuario y kernel.
Tenemos que pensar en alguna alternativa.
  
Después de Depurar, nos hemos dado cuenta de que el thread hijo tiene acceso al trampolin y trapframe del padre.
En consecuencia, modifica dichas partes cuando no debería hacerlo. Lo que debemos hacer es establecer un espacio de direcciones (tabla de páginas privada)
secundario donde añadir copias de las páginas del padre. Luego, asegurarnos de que el thread usa dichas páginas y no las del padre.

PSEUDOCÓDIGO
  1.  averiguar cómo se define un espacio de direcciones
  2.  establecer el espacio de direcciones secundario
  3.  añadir las páginas correspondientes a este espacio de direcciones (clone)
  4.  Asegurarnos de que el proceso hijo emplea dichas páginas.
 (5). En exec posiblemente debamos hacer algún cambio




1.


Vamos a averiguar todas las cosas asociadas al establecimiento del espacio de direcciones.

>>PROC.H 

En este fichero parece haber una definición formal de instancia de tabla de páginas. Aquí seguramente nosotros debamos 
añadir la definición de la segunda tabla de páginas privada.

>>PROC.C 

Una de las funciones importantes en las que debemos prestar atención es allocproc(). Lo que realiza esta función es buscar en la lista
de procesos si hay una entrada vacía. Si existe, inicializa un estado a dicho proceso para que sea capaz de correr en el kernel y retornan con el lock 
del proceso tomado.

Dentro de esta función, allocata espacio de para la página de trapframe y también crea una nueva 
tabla de páginas vacía. Por último, crea un nuevo contexto ejecutando en forkret, para retornar directamente 
en espacio de usuario.

Realmente, hay un factor importante al que debemos prestar atención. En allocproc, se asignan punteros al trapframe y espacio de direcciones. Sin embargo,
los threads estos no los utilizan porque los cambian por los del padre. En lugar de crear otra tabla de páginas y trapframe adicional, podríamos reutilizar los creados en esta función.
Para ello, en proc.h crearemos otro pagetable y trapframe secundario.

Con lo cual, la función alloc añadimso lo siguiente:

//.....

  // Allocate a trapframe page.
  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  //salvamos puntero de trapframe
  p->private_trapframe = p->trapframe;

  // An empty user page table.
  p->pagetable = proc_pagetable(p);
  if(p->pagetable == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }

  //salvamos puntero pagetable
  p->private_pagetable = p->pagetable;

//.....













