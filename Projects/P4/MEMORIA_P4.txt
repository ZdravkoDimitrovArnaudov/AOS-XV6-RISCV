---------------------
------MEMORIA P4-----
---------------------

Indice
    1. Objetivos
    2. Planteamiento
    3. Desarrollo
    4. Observaciones


1.

El objetivo de esta práctica consiste en poder añadir correctamente kernel threads.
Necesitamos realizar 3 cosas:
    -añadir una llamada al sistema que genere kernel threads, llamada clone() y otra que haga wait al thread con la llamada join().
    -usar clone() para construir una librería de thread (en espacio de usuario) con llamadas thread_create() y thread_join();
    -soporte para locks y variables condicionales.
        +para locks: lock_init(), lock_acquire(), lock_release()
        +para variables condicionales: cv_init(), cv_wait(), cv_signal().



2.

El prototipo de la llamada al sistema clone, deberá ser:
    int clone (void(*fcn)(void*), void *arg, void*stack);

Esta llamada crea un nuevo kernel thread que comparte el espacio de direcciones del proceso que lo crea.
El nuevo thread/proceso emplea "stack" como su stack de usuario. Tendrá el tamaño de una página 
y deberá estar alineada. El nuevo proceso, comienza ejecutando en la dirección indicada por el puntero fcn. 
Al igual que el fork(), al final el PID del nuevo thread se comparte con el padre.


La segunda nueva llamada al sistema es join(void **stack). Esta syscall, espera a que termine el proceso hijo
que comparte el espacio de direcciones del proceso padre. Devuelve el PID del hijo esperado, o -1 si no existe.
La localización del stack de usuario del hijo está copiado en el argumento "stack".

Es necesario también pensar en cómo gestionar algunas llamadas al sistema existentes como wait y exit.
Para wait, ¿será necesario esperar a un proceso hijo que no comparte el espacio de direcciones del padre?
Para exit(), debe funcionar como antes. Para ambos procesos y threads se deberán hacer pocos cambios.

>>LIBRERÍA DE THREAD 

La librería de thread, deberá componer la llamada thread_create (void *start_routine)(void*), void *arg).
Esta rutina tendrá que llamar a malloc() para crear el nuevo userstack, usar clone() para poder crear el thread hijo y ponerlo
a ejecutar. Una llamada thread_join() también deberá ser usada, que emplea la llamada join del sistema, libera el user stack y luego devuelve.

La librería de thread, también deberá tener un simple spinlock. Tiene que haberun tipo lock_t que uno emplea para declarar un
lock y dos rutinas: lock_acquire(lock_t*) y lock_release(lock_t*), que adquieren y  liberan el lock.
También, lock_init(lock_t *) nos servirá para inicializar el lock.

Finalmente, deberemos tener una variable condicional y las respectivas rutinas: cond_t, cv_wait (cond_t*, lock_t*)
y cv_signal(cond_t*). Estas rutinas deberían hacer lo esperado: poner al llamante a dormir (y liberar el lock) o despertar 
al thread dormido respectivamente. Deberán añadirse llamadas al sistema adicionales para cumplir con esto.
Dejalo para el final del proyecto.

Para probar el código, usar los test. También, es recomendable crear pequeñas piezas de código para comprobar 
que todo funciona.


>>RESUMEN

El objetivo esencial es generar una librería de thread para el espacio de usuairo. Esta librería compone una serie de funciones que aportan gestión de threads,
locks y variables condicionales. 

En cuanto a los threads, existen dos llamadas que pueden hacerse: thread_create y thread_join. La primera de ellas hará uso de la llamada clone() y la segudna de join(). Para la implementación
de clone(), podemos observar el comportamiento de fork(), pues debemos hacer que este proceso comparta el espacio de direcciones del proceso padre, pero su stack será distinto.

De cara a los locks, saber que debemos inicializar, acquire y release. Para esto, podemos basarnos en la implementación del spinlock, acquire y realease implementados.
Sobre las variables condicionales, lo dejaremos para el final.



3.


Inicialmente, lo que haremos será estructurar la librería de threads. 
Para poder definir estas funciones, necesitamos un tipo de dato lock_t. Este lo vamos a definir en user.h como typedef uint lock_t.

Nuestro primer objetivo es completar la funcionalidad thread_create. Esta llamada lo que deberá hacer es llamar a malloc() para crear 
el stack de usuario que empleará el thread (destacamos que su stack se situará en el heap del proceso padre). Después, se empleará la llamada al sistema 
clone() para crear el proceso hijo y ejecutarlo.

El stack tiene tamaño de una página y además la dirección virtual debe estar alineada a página.
Esto quiere decir que si hacemos va %  PGSIZE, nos debe dar cero (ejemplo en vmc, uvmunmap()). Si nos da distinto, significa que no está alineada y por tanto debemos hacerlo.
Para poder hacer esto, ampliamos la dirección hasta que se pueda alinear a pagina: stack = stack + (PAGE_SIZE - (va % PGSIZE)).

De esta forma, la función queda así:

int thread_create(void (*start_routine)(void*),  void *arg){
    
    uint64 va;

    //creamos el stack del thread con tamaño de pagina 1
    void *stack;
    if (!(stack = malloc (PAGE_SIZE))){
        printf ("Error: No se ha podido allocatar el stack en el heap del proceso padre.\n");
        return -1;
    }

    //comprobamos si la dirección está alineada a página. En caso contrario hacerlo.
    va = (uint64) stack;
    if ((va % PAGE_SIZE) != 0){
        stack = stack + (PAGE_SIZE - (va % PAGE_SIZE));
    }
    
    return clone (start_routine, arg, stack);
}


Vamos a proceder a crear la llamada al sistema clone(). Como ya sabemos, modificaremos los ficheros típicos.

>>SYSCALL.h

// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
#define SYS_read    5
#define SYS_kill    6
#define SYS_exec    7
#define SYS_fstat   8
#define SYS_chdir   9
#define SYS_dup    10
#define SYS_getpid 11
#define SYS_sbrk   12
#define SYS_sleep  13
#define SYS_uptime 14
#define SYS_open   15
#define SYS_write  16
#define SYS_mknod  17
#define SYS_unlink 18
#define SYS_link   19
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_clone 22

>>SYSCALL.c 

//...

extern uint64 sys_wait(void);
extern uint64 sys_write(void);
extern uint64 sys_uptime(void);
extern uint64 sys_clone (void);

static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_clone]   sys_clone
};



>>USYS.Pl 

entry("clone");


>>USER.h

// system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
int pipe(int*);
int write(int, const void*, int);
int read(int, void*, int);
int close(int);
int kill(int);
int exec(char*, char**);
int open(const char*, int);
int mknod(const char*, short, short);
int unlink(const char*);
int fstat(int fd, struct stat*);
int link(const char*, const char*);
int mkdir(const char*);
int chdir(const char*);
int dup(int);
int getpid(void);
char* sbrk(int);
int sleep(int);
int uptime(void);
int clone(void(*fcn)(void*), void *arg, void*stack);

>>SYSPROC.C 

uint64
sys_clone (void)
{
  void *stack;
  void *arg;
  void *fcn;

   //obtenemos puntero función
   if(argaddr(0, &fcn) < 0){
     return -1;
   }

   //obtenemos puntero a argumento de función
   if(argaddr(1, &arg) < 0){
     return -1;
   }

   //obtenemos putnero a stack de usuario
   if(argaddr(2, &stack) < 0){
     return -1;
   }
   
  return clone(fcn, arg, stack);
}


>>DEFS.h

// proc.c
int             cpuid(void);
void            exit(int);
int             fork(void);
int             growproc(int);
void            proc_mapstacks(pagetable_t);
pagetable_t     proc_pagetable(struct proc *);
void            proc_freepagetable(pagetable_t, uint64);
int             kill(int);
struct cpu*     mycpu(void);
struct cpu*     getmycpu(void);
struct proc*    myproc();
void            procinit(void);
void            scheduler(void) __attribute__((noreturn));
void            sched(void);
void            sleep(void*, struct spinlock*);
void            userinit(void);
int             wait(uint64);
void            wakeup(void*);
void            yield(void);
int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
void            procdump(void);
int             clone(void(*fcn)(void*), void *arg, void*stack)

>>PROC.C 













